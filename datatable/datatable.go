// Copyright (c) 2021 BlueStorm
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFINGEMENT IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package datatable

import (
	"database/sql"
	"errors"
	"github.com/BlueStorm001/gsql/util"
	"strings"
)

type ISQL interface {
	DataSet(orm *ORM) (*DataSet, error)
	DataTable(orm *ORM) (*DataTable, error)
	Select(orm *ORM) error
	Count(orm *ORM) error
	Insert(orm *ORM) error
	Update(orm *ORM) error
	Delete(orm *ORM) error
	Where(orm *ORM, wheres ...string) error
	OrderBy(orm *ORM, field string) error
	GroupBy(orm *ORM, field string) error
	Limit(orm *ORM, limit int, offset ...int) error
	Execute(orm *ORM) (sql.Result, error)
	Connect() error
	Close() error
}

type Auth struct {
	User string
	Pass string
}

type SqlResult struct {
	//error
	Error error

	//数据集合
	DataTable *DataTable

	// LastInsertId returns the integer generated by the database
	// in response to a command. Typically this will be from an
	// "auto increment" column when inserting a new row. Not all
	// databases support this feature, and the syntax of such
	// statements varies.
	LastInsertId int64 //新id

	// RowsAffected returns the number of rows affected by an
	// update, insert, or delete. Not every database or database
	// driver may support this.
	RowsAffected int64 //影响的行数
}

type Serve struct {
	ISQL     ISQL
	Host     string
	Port     int
	Database string
	Auth     *Auth
	//最大连接数
	ConnectMax int //Maximum number of connections
	//超时(秒)
	Timeout    int //Second/1
	Error      error
	DriveServe func(s *Serve) (db *sql.DB, err error) //mode 1
	Drive      func() (db *sql.DB, err error)         // mode 2
	DriveMode  int
}

type findKind uint

const (
	normal findKind = iota
	likeMode
	regXMode
)

type Column struct {
	Name   string
	Type   string
	Length int64
}

type Field struct {
	Tag string
	Val interface{}
}

type DataTable struct {
	Name    string
	Columns []*Column
	Rows    []map[string]interface{}
	Count   int
	mode    findKind
}

type DataSet struct {
	Tables []*DataTable
}

type UseMode int

const (
	Not UseMode = iota
	Get
	Add
	Set
	Del
	Count
)

type ORM struct {
	SqlCommand   *util.Builder
	SqlValues    []interface{}
	SqlStructMap map[string]*Field
	TableName    string
	Mode         UseMode
	Columns      map[string]struct{}
	ColumnMode   int //1 use -1 exclude
}

type SqlRows struct {
	*sql.Rows
}

func (rows *SqlRows) GetDataSet() (ds *DataSet, err error) {
	var dt *DataTable
	dt, err = rows.GetDataTable()
	if err != nil {
		return
	}
	ds = new(DataSet)
	ds.Tables = append(ds.Tables, dt)
	for rows.NextResultSet() {
		dt, err = rows.GetDataTable()
		if err != nil {
			return
		}
		ds.Tables = append(ds.Tables, dt)
	}
	return
}

func (rows *SqlRows) GetDataTable() (dt *DataTable, err error) {
	var columns []*sql.ColumnType
	columns, err = rows.ColumnTypes()
	if err != nil {
		return
	}
	columnLen := len(columns)
	if columnLen == 0 {
		err = errors.New("no column")
		return
	}
	dt = new(DataTable)
	dt.Columns = make([]*Column, columnLen)
	data := make([]interface{}, columnLen)
	for i := range data {
		data[i] = new(interface{})
		column := &Column{}
		column.Name = columns[i].Name()
		column.Type = columns[i].DatabaseTypeName()
		column.Length, _ = columns[i].Length()
		dt.Columns[i] = column
	}
	for rows.Next() {
		if err = rows.Scan(data...); err != nil {
			return nil, err
		}
		row := make(map[string]interface{})
		for i, d := range data {
			name := dt.Columns[i].Name
			value := *d.(*interface{})
			switch r := value.(type) {
			case []byte:
				typ := strings.ToUpper(dt.Columns[i].Type)
				switch typ {
				case "INT", "BIGINT", "SMALLINT", "TINYINT", "MEDIUMINT", "BIT":
					row[name] = util.ToInt64(value)
				case "DECIMAL", "FLOAT", "DOUBLE":
					row[name] = util.ToFloat64(value)
				case "BOOL":
					v := util.BytToStr(r)
					if v == "true" || v == "1" {
						row[name] = true
					} else {
						row[name] = false
					}
				default:
					row[name] = util.BytToStr(r)
				}
			default:
				row[name] = r
			}
		}
		dt.Rows = append(dt.Rows, row)
	}
	dt.Count = len(dt.Rows)
	return
}
